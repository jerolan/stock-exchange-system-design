# Copilot Instructions: Stock Exchange Matching Engine

## Project Purpose

This is a **pedagogical demo** of a stock exchange matching engine focused on architecture, event flow, and correct state modeling — not production-ready performance or financial protocols. The core principle:

> The market lives in memory.  
> The truth lives in the log.  
> Everything else is a projection.

## Architecture: Big Picture

```
Clients / HTTP
     ↓
  Server (API)
     ↓
Matching Engine (core CP)
     ↓
  EventBus (decoupling)
     ↓
  Views (read models)

Matching Engine → WAL (durability)
```

**Key insight**: The center of the system is NOT a database — it's an ordered log (WAL) plus in-memory data structures.

### Layer Responsibilities

| Component            | Location                 | Responsibility                                                   |
| -------------------- | ------------------------ | ---------------------------------------------------------------- |
| **Matching Engine**  | `core/matchingEngine.ts` | Single-thread, deterministic, price-time matching (hot path, CP) |
| **Order Book**       | `core/orderBook.ts`      | In-memory FIFO queues per price level, O(1) cancellations        |
| **WAL**              | `infra/wal.ts`           | Append-only truth, crash recovery (CP)                           |
| **EventBus**         | `infra/eventBus.ts`      | In-memory decoupling core→views (not durable)                    |
| **Views**            | `views/`                 | Read projections, eventually consistent (AP)                     |
| **Server**           | `api/server.ts`          | HTTP adapter (no business logic)                                 |
| **Composition Root** | `composition.ts`         | Dependency wiring, bootstrap, replay orchestration               |

## Critical Patterns

### 1. Dependency Composition (No DI Framework)

All dependencies are **explicitly wired** in `composition.ts`. No singletons, no magic containers.

- **Factory pattern**: Components accept `deps` in constructor
- **Interface segregation**: Each component declares minimal dependencies (e.g., `type WAL = { append(event: Event): void }`)
- **Testability**: Mock dependencies by passing stubs to constructors

Example from `matchingEngine.ts`:

```typescript
type MatchingEngineDeps = {
  wal: WAL;
  eventBus: EventBus;
};

export class MatchingEngine {
  constructor({ wal, eventBus }: MatchingEngineDeps) {
    this.wal = wal;
    this.eventBus = eventBus;
  }
}
```

### 2. Event Sourcing + WAL

**Rule**: If it's not in the WAL, it didn't happen.

- Every command generates events (`NEW_ORDER`, `CANCEL_ORDER`)
- Trades are generated by the matching engine and **written to WAL first**, then published to EventBus
- On crash, replay WAL to reconstruct in-memory state

See `matchingEngine.process()` — single entry point for both replay and live events.

### 3. Hot Path vs Cold Path

- **Hot path**: `MatchingEngine` + `OrderBook` (synchronous, deterministic, no I/O except WAL)
- **Cold path**: `Views` consume events slowly (simulated lag via `applyIntervalMs`)

This demonstrates **eventual consistency** — market state updates instantly, views lag intentionally.

### 4. CQRS (Command Query Responsibility Segregation)

- **Commands**: Flow through `MatchingEngine`, mutate state, write to WAL
- **Queries**: Read from `Views` (e.g., `openOrdersView.list()`)
- Views do NOT update during replay — only in live mode (see `composition.ts`)

### 5. CAP Theorem Application

- **Matching Engine**: CP (consistency + partition tolerance, blocks on failure)
- **WAL**: CP (durable, ordered)
- **Views**: AP (available, eventually consistent)
- **EventBus**: In-memory only (not part of truth)

## Developer Workflows

### Running the app

```bash
bun install
bun run src/main.ts
```

### Testing crash recovery

```bash
curl http://localhost:3000/orders/open  # Check state
curl -X POST http://localhost:3000/crash  # Kill process
bun run src/main.ts  # Restart → replays WAL
```

### Key HTTP endpoints

- `GET /orders/open?side=BUY|SELL` — Query view (may lag)
- `GET /health` — Check EventBus backlog
- `POST /crash` — Intentional crash for demo

## Code Conventions

### TypeScript + JSDoc

- **JSDoc required** for public APIs (see `.github/instructions/docs.ts.instructions.md`)
- Use standard tags: `@param`, `@returns`, `@throws`, `@example`

### No async in core

- `MatchingEngine.process()` is **synchronous** (deterministic, no race conditions)
- `MatchingEngine.match()` is a tight loop (no `await`)
- Only async: Views (intentional lag), Server (HTTP)

### Order of operations in `MatchingEngine.match()`

1. Execute trade in memory (update `buy.qty`, `sell.qty`)
2. Create `TRADE` event
3. **Write to WAL** (durability)
4. Publish to EventBus (decoupling)
5. Remove filled orders from `OrderBook`

**Critical**: WAL write happens before EventBus publish. If crash occurs after WAL write but before EventBus publish, replay will regenerate the event.

### OrderBook internals

- **Price levels**: `Map<number, DoublyLinkedList<Order>>`
- **O(1) cancellation**: `orderId → { order, node }` index
- **FIFO per level**: Price-time priority via linked list

Example:

```typescript
cancel(orderId: string) {
  const ref = this.index.get(orderId);
  if (!ref) return;
  const { order, node } = ref;
  const level = book.get(order.price);
  level.remove(node);  // O(1) via node reference
  this.index.delete(orderId);
}
```

### Event types (core/types.ts)

All system events are union type `Event = NewOrderEvent | CancelOrderEvent | TradeEvent`.

- `NEW_ORDER`: External command
- `CANCEL_ORDER`: External command
- `TRADE`: **Generated by matching engine** (output, not input)

**Important**: `MatchingEngine.process()` ignores `TRADE` events during replay (they're outputs, not inputs).

## Integration Points

### Bun runtime

- Uses `Bun.serve()` for HTTP server
- File I/O via Node.js `fs` APIs (sync for WAL durability)

### No external dependencies

- Zero npm packages (except dev: `@types/bun`)
- Pure TypeScript + Bun standard library

## Common Tasks

### Adding a new event type

1. Define in `core/types.ts` (e.g., `ModifyOrderEvent`)
2. Add to `Event` union
3. Handle in `MatchingEngine.process()` switch
4. Update views to consume new event
5. Consider WAL replay compatibility

### Adding a new view

1. Create in `views/` (follow `openOrdersView.ts` pattern)
2. Subscribe to EventBus in `views.ts`
3. Wire in `composition.ts`
4. Expose via endpoint in `api/server.ts`

### Debugging state inconsistencies

1. Check WAL size: `wal.size()`
2. Check EventBus backlog: `eventBus.size()`
3. Verify view lag: `GET /health`
4. Compare `engine.snapshot()` (hot) vs `openOrdersView.list()` (cold)

## Anti-patterns (Avoid)

- ❌ Making `MatchingEngine.match()` async
- ❌ Writing to DB instead of WAL
- ❌ Coupling views to matching engine (use EventBus)
- ❌ Adding global singletons (use `composition.ts`)
- ❌ Reprocessing `TRADE` events in `process()`

## References

- **README.md**: Full conceptual explanation
- **composition.ts**: See dependency wiring example
- **matchingEngine.ts**: Study replay vs live distinction
- **orderBook.ts**: O(1) data structure techniques

## Questions to Ask When Unsure

1. Is this change in the hot path (matching) or cold path (views)?
2. Does this event need to be in the WAL?
3. Will this break crash recovery / replay?
4. Should this be in `composition.ts` or inside a component?
